//--------------------------------------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------------------------------------

// #pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

#pragma kernel ScreenSpaceReflectionsTracing            SSR_TRACE
#pragma kernel ScreenSpaceReflectionsReprojection       SSR_REPROJECT
#pragma kernel ScreenSpaceReflectionsDenoiseInpainting  SSR_DENOISE_INPAINTING

#pragma multi_compile _ DEPTH_SOURCE_NOT_FROM_MIP_CHAIN

// Tweak parameters.
// #define DEBUG
#define SSR_TRACE_BEHIND_OBJECTS
#define SSR_TRACE_TOWARDS_EYE
#define SSR_TRACE_EPS            0.00024414 // 2^-12, should be good up to 4K

//--------------------------------------------------------------------------------------------------
// Included headers
//--------------------------------------------------------------------------------------------------

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ScreenSpaceLighting/ScreenSpaceLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ScreenSpaceLighting/ShaderVariablesScreenSpaceReflection.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"


#ifdef DEBUG_DISPLAY
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Debug.hlsl"
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
#endif

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingCommon.hlsl"

//--------------------------------------------------------------------------------------------------
// Inputs & outputs
//--------------------------------------------------------------------------------------------------

#ifdef DEBUG
    RW_TEXTURE2D(float4, _SsrDebugTexture);
#endif

// For opaque we do the following operation:
// - Render opaque object in depth buffer
// - Generate depth pyramid from opaque depth buffer
// - Trigger ray from position recover from depth pyramid and raymarch with depth pyramid
// For transparent reflection we chose to not regenerate a depth pyramid to save performance. So we have
// - Generate depth pyramid from opaque depth buffer
// - Trigger ray from position recover from depth buffer (use depth pyramid) and raymarch with depth pyramid
// - Render transparent object with reflection in depth buffer in transparent prepass
// - Trigger ray from position recover from new depth buffer and raymarch with opaque depth pyramid
// So we need a seperate texture for the mip chain and for the depth source when doing the transprent reflection
#ifdef DEPTH_SOURCE_NOT_FROM_MIP_CHAIN
TEXTURE2D_X(_DepthTexture);
#endif

#ifdef SSR_TRACE
    TEXTURE2D_X_UINT2(         _StencilTexture);
    RW_TEXTURE2D_X(float4, _SsrHitPointTexture);
#elif defined(SSR_REPROJECT)
       TEXTURE2D_X(        _SsrHitPointTexture);
    RW_TEXTURE2D_X(float4, _SsrLightingTextureRW); // ShaderVariablesScreenSpaceLighting.hlsl already pulls in a non-RW _SsrLightingTexture
       TEXTURE2D_X(        _PrevSSRLightingTexture);
    RW_TEXTURE2D_X(float4, _SSRAccumTexture);
#else // defined(SSR_DENOISE_INPAINTING)
       TEXTURE2D_X(        _SsrHitPointTexture);
       TEXTURE2D_X(        _PrevSSRLightingTexture);
    RW_TEXTURE2D_X(float4, _SsrLightingTextureRW); // ShaderVariablesScreenSpaceLighting.hlsl already pulls in a non-RW _SsrLightingTexture
    RW_TEXTURE2D_X(float4, _SSRAccumTexture);
#endif

    TEXTURE2D_X(            _SsrClearCoatMaskTexture);
    StructuredBuffer<int2>  _DepthPyramidMipLevelOffsets;
    StructuredBuffer<uint>  _CoarseStencilBuffer;

//--------------------------------------------------------------------------------------------------
// Implementation
//--------------------------------------------------------------------------------------------------

void GetNormalAndPerceptualRoughness(uint2 positionSS, out float3 normalWS, out float perceptualRoughness)
{
    // Load normal and perceptualRoughness.
    NormalData normalData;
    DecodeFromNormalBuffer(positionSS, normalData);
    normalWS = normalData.normalWS;
    float4 packedCoatMask = _SsrClearCoatMaskTexture[COORD_TEXTURE2D_X(positionSS)];
    perceptualRoughness = HasClearCoatMask(packedCoatMask) ? CLEAR_COAT_PERCEPTUAL_ROUGHNESS : normalData.perceptualRoughness;
}

void WriteDebugInfo(uint2 positionSS, float4 value)
{
#ifdef DEBUG
    _SsrDebugTexture[positionSS] = value;
#endif
}

#ifdef SSR_TRACE

[numthreads(8, 8, 1)]
void ScreenSpaceReflectionsTracing(uint3 groupId          : SV_GroupID,
                                   uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    uint2 positionSS = dispatchThreadId.xy;

    // Check HTile first. Note htileAddress should be already in scalar before WaveReadLaneFirst, but forcing it to be sure.
    // TODO: Verify the need of WaveReadLaneFirst
    uint htileAddress = WaveReadLaneFirst(Get1DAddressFromPixelCoord(groupId.xy, _CoarseStencilBufferSize.xy, groupId.z));
    uint htileValue   = _CoarseStencilBuffer[htileAddress];

    bool doesntReceiveSSR = (htileValue & _SsrStencilBit) == 0;
    if (doesntReceiveSSR)
    {
        WriteDebugInfo(positionSS, -1);
        return;
    }

    uint stencilValue = GetStencilValue(LOAD_TEXTURE2D_X(_StencilTexture, dispatchThreadId.xy));
    doesntReceiveSSR = (stencilValue & _SsrStencilBit) == 0;
    if (doesntReceiveSSR)
    {
        WriteDebugInfo(positionSS, -1);
        return;
    }

    float2 positionNDC = positionSS * _ScreenSize.zw + (0.5 * _ScreenSize.zw); // Should we precompute the half-texel bias? We seem to use it a lot.

#ifdef DEPTH_SOURCE_NOT_FROM_MIP_CHAIN
    float  deviceDepth = LOAD_TEXTURE2D_X(_DepthTexture, positionSS).r;
#else
    float  deviceDepth = LOAD_TEXTURE2D_X(_CameraDepthTexture, positionSS).r;
#endif

    bool killRay = deviceDepth == UNITY_RAW_FAR_CLIP_VALUE;

    float3 positionWS = ComputeWorldSpacePosition(positionNDC, deviceDepth, UNITY_MATRIX_I_VP); // Jittered
    float3 V          = GetWorldSpaceNormalizeViewDir(positionWS);

    float3 N;
    float perceptualRoughness;
    GetNormalAndPerceptualRoughness(positionSS, N, perceptualRoughness);

    float3 camPosWS = GetCurrentViewPosition();

    // Apply normal bias with the magnitude dependent on the distance from the camera.
    // Unfortunately, we only have access to the shading normal, which is less than ideal...
    positionWS  = camPosWS + (positionWS - camPosWS) * (1 - 0.001 * rcp(max(dot(N, V), FLT_EPS)));
    deviceDepth = ComputeNormalizedDeviceCoordinatesWithZ(positionWS, UNITY_MATRIX_VP).z;

    // Ref. #1: Michal Drobot - Quadtree Displacement Mapping with Height Blending.
    // Ref. #2: Yasin Uludag  - Hi-Z Screen-Space Cone-Traced Reflections.
    // Ref. #3: Jean-Philippe Grenier - Notes On Screen Space HIZ Tracing.
    // Warning: virtually all of the code below assumes reverse Z.

    // We start tracing from the center of the current pixel, and do so up to the far plane.
    float3 rayOrigin = float3(positionSS + 0.5, deviceDepth);

#if 0
    // TODO: this does not match GGX.
    float3 R = reflect(-V, N);
#else
    // Pick which subpixel we will be launching our effects from
    float subPixelSample = GetBNDSequenceSample(positionSS, _RaytracingFrameIndex, 3);
    int subPixel = clamp((int)(subPixelSample * 4.0), 0, 3);
    uint2 shift = HalfResIndexToCoordinateShift[subPixel];

    //// Pixel where we will store the result of the raytracing
    //uint2 outputCoord = halfResCoord * 2;

    // Pixel coordinate in full res of the pixel that we will be using for our computation
    uint2 sourceCoord = positionSS + shift;

    NormalData normalData;
    DecodeFromNormalBuffer(sourceCoord, normalData);

    float3x3 localToWorld = GetLocalFrame(normalData.normalWS);

    // Compute the actual roughness
    float roughness = PerceptualRoughnessToRoughness(normalData.perceptualRoughness);

    // Generate the new sample (follwing values of the sequence)
    int globalSampleIndex = _FrameCount;
        //round(_Time*1024.0f);
        //_RaytracingFrameIndex;
    float2 Xi;
    Xi.x = GetBNDSequenceSample(positionSS, globalSampleIndex, 0);
    Xi.y = GetBNDSequenceSample(positionSS, globalSampleIndex, 1);

    // Importance sample the direction
    float3 R = float3(0.0, 0.0, 0.0);
    float NdotL, NdotH, VdotH;
    SampleGGXDir(Xi, V, localToWorld, roughness, R, NdotL, NdotH, VdotH);

    if (NdotL < 0.001f)
    {
        WriteDebugInfo(positionSS, -1);
        return;
    }

    float D = D_GGX(NdotH, roughness);
    float pdf = D * NdotH / (4.0 * VdotH);

    if (pdf < 0.001f)
    {
        WriteDebugInfo(positionSS, -1);
        return;
    }
#endif

    float3 reflPosWS  = positionWS + R;
    float3 reflPosNDC = ComputeNormalizedDeviceCoordinatesWithZ(reflPosWS, UNITY_MATRIX_VP); // Jittered
    float3 reflPosSS  = float3(reflPosNDC.xy * _ScreenSize.xy, reflPosNDC.z);
    float3 rayDir     = reflPosSS - rayOrigin;
    float3 rcpRayDir  = rcp(rayDir);
    int2   rayStep    = int2(rcpRayDir.x >= 0 ? 1 : 0,
                             rcpRayDir.y >= 0 ? 1 : 0);
    float3 raySign  = float3(rcpRayDir.x >= 0 ? 1 : -1,
                             rcpRayDir.y >= 0 ? 1 : -1,
                             rcpRayDir.z >= 0 ? 1 : -1);
    bool   rayTowardsEye  =  rcpRayDir.z >= 0;

    // Note that we don't need to store or read the perceptualRoughness value
    // if we mark stencil during the G-Buffer pass with pixels which should receive SSR,
    // and sample the color pyramid during the lighting pass.
    killRay = killRay || (reflPosSS.z <= 0);
    killRay = killRay || (dot(N, V) <= 0);
    killRay = killRay || (perceptualRoughness > _SsrRoughnessFadeEnd);
#ifndef SSR_TRACE_TOWARDS_EYE
    killRay = killRay || rayTowardsEye;
#endif

    if (killRay)
    {
        WriteDebugInfo(positionSS, -1);
        return;
    }

    // Extend and clip the end point to the frustum.
    float tMax;
    {
        // Shrink the frustum by half a texel for efficiency reasons.
        const float halfTexel = 0.5;

        float3 bounds;
        bounds.x = (rcpRayDir.x >= 0) ? _ScreenSize.x - halfTexel : halfTexel;
        bounds.y = (rcpRayDir.y >= 0) ? _ScreenSize.y - halfTexel : halfTexel;
        // If we do not want to intersect the skybox, it is more efficient to not trace too far.
        float maxDepth = (_SsrReflectsSky != 0) ? -0.00000024 : 0.00000024; // 2^-22
        bounds.z = (rcpRayDir.z >= 0) ? 1 : maxDepth;

        float3 dist = bounds * rcpRayDir - (rayOrigin * rcpRayDir);
        tMax = Min3(dist.x, dist.y, dist.z);
    }

    // Clamp the MIP level to give the compiler more information to optimize.
    const int maxMipLevel = min(_SsrDepthPyramidMaxMip, 14);

    // Start ray marching from the next texel to avoid self-intersections.
    float t;
    {
        // 'rayOrigin' is the exact texel center.
        float2 dist = abs(0.5 * rcpRayDir.xy);
        t = min(dist.x, dist.y);
    }

    float3 rayPos;

    int  mipLevel  = 0;
    int  iterCount = 0;
    bool hit       = false;
    bool miss      = false;
    bool belowMip0 = false; // This value is set prior to entering the cell

    while (!(hit || miss) && (t <= tMax) && (iterCount < _SsrIterLimit))
    {
        rayPos = rayOrigin + t * rayDir;

        // Ray position often ends up on the edge. To determine (and look up) the right cell,
        // we need to bias the position by a small epsilon in the direction of the ray.
        float2 sgnEdgeDist = round(rayPos.xy) - rayPos.xy;
        float2 satEdgeDist = clamp(raySign.xy * sgnEdgeDist + SSR_TRACE_EPS, 0, SSR_TRACE_EPS);
        rayPos.xy += raySign.xy * satEdgeDist;

        int2 mipCoord  = (int2)rayPos.xy >> mipLevel;
        int2 mipOffset = _DepthPyramidMipLevelOffsets[mipLevel];
        // Bounds define 4 faces of a cube:
        // 2 walls in front of the ray, and a floor and a base below it.
        float4 bounds;

        bounds.xy = (mipCoord + rayStep) << mipLevel;
        bounds.z  = LOAD_TEXTURE2D_X(_CameraDepthTexture, mipOffset + mipCoord).r;

        // We define the depth of the base as the depth value as:
        // b = DeviceDepth((1 + thickness) * LinearDepth(d))
        // b = ((f - n) * d + n * (1 - (1 + thickness))) / ((f - n) * (1 + thickness))
        // b = ((f - n) * d - n * thickness) / ((f - n) * (1 + thickness))
        // b = d / (1 + thickness) - n / (f - n) * (thickness / (1 + thickness))
        // b = d * k_s + k_b
        bounds.w = bounds.z * _SsrThicknessScale + _SsrThicknessBias;

        float4 dist      = bounds * rcpRayDir.xyzz - (rayOrigin.xyzz * rcpRayDir.xyzz);
        float  distWall  = min(dist.x, dist.y);
        float  distFloor = dist.z;
        float  distBase  = dist.w;

        // Note: 'rayPos' given by 't' can correspond to one of several depth values:
        // - above or exactly on the floor
        // - inside the floor (between the floor and the base)
        // - below the base
    #if 0
        bool belowFloor  = (raySign.z * (t - distFloor)) <  0;
        bool aboveBase   = (raySign.z * (t - distBase )) >= 0;
    #else
        bool belowFloor  = rayPos.z  < bounds.z;
        bool aboveBase   = rayPos.z >= bounds.w;
    #endif
        bool insideFloor = belowFloor && aboveBase;
        bool hitFloor    = (t <= distFloor) && (distFloor <= distWall);

        // Game rules:
        // * if the closest intersection is with the wall of the cell, switch to the coarser MIP, and advance the ray.
        // * if the closest intersection is with the heightmap below,  switch to the finer   MIP, and advance the ray.
        // * if the closest intersection is with the heightmap above,  switch to the finer   MIP, and do NOT advance the ray.
        // Victory conditions:
        // * See below. Do NOT reorder the statements!

    #ifdef SSR_TRACE_BEHIND_OBJECTS
        miss      = belowMip0 && insideFloor;
    #else
        miss      = belowMip0;
    #endif
        hit       = (mipLevel == 0) && (hitFloor || insideFloor);
        belowMip0 = (mipLevel == 0) && belowFloor;

        // 'distFloor' can be smaller than the current distance 't'.
        // We can also safely ignore 'distBase'.
        // If we hit the floor, it's always safe to jump there.
        // If we are at (mipLevel != 0) and we are below the floor, we should not move.
        t = hitFloor ? distFloor : (((mipLevel != 0) && belowFloor) ? t : distWall);
        rayPos.z = bounds.z; // Retain the depth of the potential intersection

        // Warning: both rays towards the eye, and tracing behind objects has linear
        // rather than logarithmic complexity! This is due to the fact that we only store
        // the maximum value of depth, and not the min-max.
        mipLevel += (hitFloor || belowFloor || rayTowardsEye) ? -1 : 1;
        mipLevel  = clamp(mipLevel, 0, maxMipLevel);

        // mipLevel = 0;

        iterCount++;
    }

    // Treat intersections with the sky as misses.
    miss = miss || ((_SsrReflectsSky == 0) && (rayPos.z == 0));
    hit  = hit && !miss;

    if (hit)
    {
        // Note that we are using 'rayPos' from the penultimate iteration, rather than
        // recompute it using the last value of 't', which would result in an overshoot.
        // It also needs to be precisely at the center of the pixel to avoid artifacts.
        float2 hitPositionNDC = floor(rayPos.xy) * _ScreenSize.zw + (0.5 * _ScreenSize.zw); // Should we precompute the half-texel bias? We seem to use it a lot.
        _SsrHitPointTexture[COORD_TEXTURE2D_X(positionSS)] = float4(hitPositionNDC, roughness*t, pdf);
    }
    //else
    //{
    //    _SsrHitPointTexture[COORD_TEXTURE2D_X(positionSS)] = float4(-1, -1 , 32767.0f, -1);
    //}

    // If we do not hit anything, 'rayPos.xy' provides an indication where we stopped the search.
    WriteDebugInfo(positionSS, float4(rayPos.xy, iterCount, hit ? 1 : 0));
}

#elif defined(SSR_REPROJECT)

float PerceptualRoughnessFade(float perceptualRoughness, float fadeRcpLength, float fadeEndTimesRcpLength)
{
    float t = Remap10(perceptualRoughness, fadeRcpLength, fadeEndTimesRcpLength);
    return Smoothstep01(t);
}

[numthreads(8, 8, 1)]
void ScreenSpaceReflectionsReprojection(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    uint2 positionSS = dispatchThreadId.xy;

    // TODO: this texture is sparse (mostly black). Can we avoid reading every texel? How about using Hi-S?
    float4 srcData = LOAD_TEXTURE2D_X(_SsrHitPointTexture, positionSS);

    float2 hitPositionNDC = srcData.xy;

    float3 N;
    float perceptualRoughness;
    GetNormalAndPerceptualRoughness(positionSS, N, perceptualRoughness);

    // TODO: filtering is quite awful. Needs to be non-Gaussian, bilateral and anisotropic.
    float mipLevel = lerp(0, _SsrColorPyramidMaxMip, perceptualRoughness);

    float tmpCoef = PerceptualRoughnessFade(perceptualRoughness, _SsrRoughnessFadeRcpLength, _SsrRoughnessFadeEndTimesRcpLength);

    // TODO: it's important to account for occlusion/disocclusion to avoid artifacts in motion.
    // This would require keeping the depth buffer from the previous frame.
    float2 motionVectorNDC;
    DecodeMotionVector(SAMPLE_TEXTURE2D_X_LOD(_CameraMotionVectorsTexture, s_linear_clamp_sampler, min(hitPositionNDC, 1.0f - 0.5f * _ScreenSize.zw) * _RTHandleScale.xy, 0), motionVectorNDC);
    float2 prevFrameNDC = hitPositionNDC - motionVectorNDC;
    float2 prevFrameUV = prevFrameNDC * _ColorPyramidUvScaleAndLimitPrevFrame.xy;

    float2 curFrameUV0 = hitPositionNDC * _ColorPyramidUvScaleAndLimitPrevFrame.xy;
    //float3 color0 = SAMPLE_TEXTURE2D_X_LOD(_PrevSSRLightingTexture, s_trilinear_clamp_sampler, curFrameUV0, mipLevel).rgb;
    //float  opacity0 = EdgeOfScreenFade(prevFrameNDC, _SsrEdgeFadeRcpLength) * tmpCoef;
    float4 prevData = _PrevSSRLightingTexture[COORD_TEXTURE2D_X(positionSS)];
    float3 color0   = prevData.rgb;
    float  opacity0 = prevData.a;

    if (max(hitPositionNDC.x, hitPositionNDC.y) == 0)
    {
        // Miss.
        //_SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = float4(color0, 0.0f) * opacity0;
        //_SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = 0.0f;
        return;
    }

    // TODO: optimize with max().
    if ((prevFrameUV.x < 0) || (prevFrameUV.x > _ColorPyramidUvScaleAndLimitPrevFrame.z) ||
        (prevFrameUV.y < 0) || (prevFrameUV.y > _ColorPyramidUvScaleAndLimitPrevFrame.w))
    {
        // Off-screen.
        //_SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = 0.0f;
        return;
    }

    // Note that the color pyramid uses it's own viewport scale, since it lives on the camera.

    float2 curFrameNDC = prevFrameNDC;
    float2 curFrameUV = curFrameNDC * _ColorPyramidUvScaleAndLimitPrevFrame.xy;

    float3 color   = SAMPLE_TEXTURE2D_X_LOD(_ColorPyramidTexture, s_trilinear_clamp_sampler, prevFrameUV, mipLevel).rgb;
    float  opacity = EdgeOfScreenFade(curFrameNDC, _SsrEdgeFadeRcpLength) * tmpCoef;

    //color   = lerp(color, color0, 0.5f);
    //color = color0;
    //color = (color + color0)*0.5f;
    //opacity = max(opacity, opacity0);

    // Disable SSR for negative, infinite and NaN history values.
    uint3 intCol   = asuint(color);
    bool  isPosFin = Max3(intCol.r, intCol.g, intCol.b) < 0x7F800000;

    color   = isPosFin ? color   : 0;
    opacity = isPosFin ? opacity : 0;

    // Use premultiplied alpha.
    //if (_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)].a <= 0.5f)
    //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(color, 1.0f);
    if (opacity > 0.0f)
        _SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = float4(color, 1.0f);// *opacity;
}
#elif defined(SSR_DENOISE_INPAINTING)
float PerceptualRoughnessFade(float perceptualRoughness, float fadeRcpLength, float fadeEndTimesRcpLength)
{
    float t = Remap10(perceptualRoughness, fadeRcpLength, fadeEndTimesRcpLength);
    return Smoothstep01(t);
}

float3 UpdateWMS(float weight, float x, float3 wms)
{
    float wsum = wms.x + weight;
    float mean = wms.y;
    float var  = wms.z;

    wsum += weight;

    return float3(
        wsum,
        mean + (weight / wsum)*(x - mean),
        var + weight * (x - mean) * (x - mean)
        );
}

float ExpAvg(float x0, float x1, float alpha)
{
    return alpha * x1 + (1.0f - alpha) * x0;
}

float3 ExpAvg(float3 x0, float3 x1, float alpha)
{
    return alpha * x1 + (1.0f - alpha) * x0;
}

float4 ExpAvg(float4 x0, float4 x1, float alpha)
{
    return alpha * x1 + (1.0f - alpha) * x0;
}

[numthreads(8, 8, 1)]
void ScreenSpaceReflectionsDenoiseInpainting(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    uint2 positionSS = dispatchThreadId.xy;

    float3 N;
    float perceptualRoughness;
    GetNormalAndPerceptualRoughness(positionSS, N, perceptualRoughness);

    // TODO: this texture is sparse (mostly black). Can we avoid reading every texel? How about using Hi-S?
    float4 srcData = LOAD_TEXTURE2D_X(_SsrHitPointTexture, positionSS);
    float2 hitPositionNDC = srcData.xy;
    float2 motionVectorNDC;
    DecodeMotionVector(SAMPLE_TEXTURE2D_X_LOD(_CameraMotionVectorsTexture, s_linear_clamp_sampler, min(hitPositionNDC, 1.0f - 0.5f * _ScreenSize.zw) * _RTHandleScale.xy, 0), motionVectorNDC);
    float2 prevFrameNDC = hitPositionNDC - motionVectorNDC;
    float2 prevFrameUV = prevFrameNDC * _ColorPyramidUvScaleAndLimitPrevFrame.xy;

    float2 curFrameUV0 = hitPositionNDC * _ColorPyramidUvScaleAndLimitPrevFrame.xy;

    float2 RTSize = 1.0f/_RTHandleScale.xy;

    float2 uv = float2(positionSS) * _RTHandleScale.xy;// _ColorPyramidUvScaleAndLimitPrevFrame.xy;

    float4 hitData = _SsrHitPointTexture[COORD_TEXTURE2D_X(positionSS)];

    float distCoef = hitData.z;
    float pdf = hitData.w;

    float2 hitUV = hitData.xy * _ColorPyramidUvScaleAndLimitPrevFrame.xy;
    if ((hitUV.x < 0) || (hitUV.x > _ColorPyramidUvScaleAndLimitPrevFrame.z) ||
        (hitUV.y < 0) || (hitUV.y > _ColorPyramidUvScaleAndLimitPrevFrame.w))
    {
        // Off-screen.

        //_SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = 0;
        return;
    }

    const int r = 1;
    bool hasNeighbour = false;
    for (int i = -r; i <= r; ++i)
    {
        for (int j = -r; j <= r; ++j)
        {
            if (i != 0 && j != 0)
            {
                float sidePDF = _SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS + int2(i, j))].w;
                if (sidePDF > 0.0f)
                {
                    hasNeighbour = true;
                    break;
                }
            }
        }
        if (hasNeighbour)
            break;
    }

    float dx = abs(_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS + int2(-1,  0))] - _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS + int2(+1,  0))]) * 0.5f;
    float dy = abs(_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS + int2( 0, -1))] - _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS + int2( 0, +1))]) * 0.5f;

    float lap = saturate((dx + dy) * 0.5f);

    float4 center = _SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)];
    float4 centerAccum = _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)];

    const float secur = 0.01f;
    bool inBound =
        //positionSS.x > secur * RTSize.x && positionSS.x < (1.0f - secur) * RTSize.x && positionSS.y > secur * RTSize.y && positionSS.y < (1.0f - secur) * RTSize.y;
        //uv.x < 1.0f - secur && uv.x > secur && uv.y < 1.0f - secur && uv.y > secur;
        //uv.x < 1.0f - secur && uv.x > secur && uv.y < 1.0f - secur && uv.y > secur;
        true;
    //bool isNewHit = pdf > 0.1f && uv.x < 0.75f && uv.x > 0.25f && uv.y < 0.75f && uv.y > 0.25f;
    //bool isNewHit = pdf > 0.001f;//&& inBound;
    //bool isNewHit = pdf > 0.00125f;//&& inBound;
    bool isNewHit = pdf > 0.0f;

    //centerAccum = ExpAvg(centerAccum, float4(0.0f, 0.0f, 0.0f, 0.0f), 0.0125f);

    const float vanish    = 0.75f;
    const float safeAccum = 0.00f;
    const float expAvgCol = 0.05f;

#if 0
    if (isNewHit && centerAccum.w < 0.25f)
    {
        _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(center.rgb, 1.0f);
        lap *= 0.0f;
    }
    else if (isNewHit && centerAccum.w >= 0.25f)
    {
        _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] =
            float4(
                //ExpAvg(centerAccum.rgb, center.rgb, 0.25f),
                lerp(centerAccum.rgb, center.rgb, 0.25f),
                1.0f);
            //float4(
            //    ExpAvg(centerAccum.rgb, center.rgb, 0.95f),
            //    1.0f);
        lap *= 0.0f;
    }
    //else if (centerAccum.w > 0.1f)
    //{
    //    _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] =
    //        float4(
    //            ExpAvg(centerAccum.rgb, float3(0.0f, 0.0f, 0.0f), expAvgCol),
    //            ExpAvg(centerAccum.w, 0.0f, expAvgCol));
    //}
    else //if (centerAccum.w <= 0.1f)
        //if (!isNewHit && hasNeighbour && centerAccum.w <= safeAccum)
    {
        float4 accum = 0.0f;
        int smplCount = 0;
        float wsum = 0.0f;
        for (int i = -r; i <= r; ++i)
        {
            for (int j = -r; j <= r; ++j)
            {
                float4 data = _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS + int2(i, j))];
                //if (i != 0 && j != 0)
                if (data.w > 0.0f && i != 0 && j != 0)
                {
                    float coef = 1.0f/sqrt(dot(float2(i, j), float2(i, j)));
                    wsum += coef;
                    accum += coef*data;
                    ++smplCount;
                }
            }
        }
        //if (accum.w > 0.0f)
        if (/*smplCount */wsum > 0)
        {
            //accum /= accum.w;
            accum /= wsum;
                //float(smplCount);
            //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = accum * 0.95f;
                //float4(accum.rgb * 0.75f, accum.w * 0.95f);
            _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(accum.rgb, 1.0f);
        }
            //float4(accum.rgb, centerAccum.w);
            //float4(accum.rgb * 0.75f, centerAccum.w * 0.75f);
            //float4(
            //    ExpAvg(centerAccum.rgb * 0.5f, accum.rgb * 0.5f, 0.75f),
            //    ExpAvg(centerAccum.w * 0.5f, accum.w * 0.5f, 0.75f));
    }
    //else
    //{
    //    lap *= 0.0f;
    //}
#endif

#if 0
    if (isNewHit && centerAccum.w <= 0.0125f)
        _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(center.rgb, 1.0f);
    else if (isNewHit && centerAccum.w > 0.0125f)
        //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(center.rgb * (1.0f - centerAccum.w) + centerAccum.w * centerAccum.rgb, 1.0f);
        _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] =
            float4(
                    ExpAvg(center.rgb, centerAccum.rgb, 0.25f),
                    //ExpAvg(centerAccum.w, 0.0f, 0.25f)
                    ExpAvg(1.0f, centerAccum.w, 0.25f)
                );
        //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(center.rgb * (1.0f - centerAccum.w) + (centerAccum.w) * centerAccum.rgb, centerAccum.w * vanish);
    else if (!isNewHit && centerAccum.w < 0.25f)
    {
        _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] =
            float4(
                    ExpAvg(center.rgb, centerAccum.rgb, 0.25f),
                    //ExpAvg(centerAccum.w, 0.0f, 0.25f)
                    ExpAvg(centerAccum.w, 0.0f, 0.45f)
                );
    }
    else if (hasNeighbour && inBound)
    {
        float3 accum = 0.0f;
        float wsum = 0.0f;
        int samplesCount = 0;
        for (int i = -r; i <= r; ++i)
        {
            for (int j = -r; j <= r; ++j)
            {
                if (i == 0 && j == 0)
                    continue;

                float4 data = _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS + int2(i, j))];
                if (data.w > 0.0f && dot(data.rgb, float3(1.0f, 1.0f, 1.0f)) > 0.1f)
                {
                    wsum += data.w;
                    accum += data.rgb;
                    ++samplesCount;
                }
            }
        }
        if (wsum > 0.0f && dot(accum.rgb, float3(1.0f, 1.0f, 1.0f)) > 0.1f)
        {
            accum /= wsum;
            //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(accum.rgb * (1.0f - centerAccum.w) + (centerAccum.w) * centerAccum.rgb, 1.0f);
            //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(ExpAvg(centerAccum.rgb, accum.rgb, 0.25f), ExpAvg(centerAccum.w, float(wsum)/((2.0f * r + 1.0f) * (2.0f * r + 1.0f)), 0.75f));
            //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(ExpAvg(centerAccum.rgb, accum.rgb, 0.75f), 0.95f*float(wsum) / float(samplesCount));
            //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(ExpAvg(centerAccum.rgb, accum.rgb, 0.75f), 0.95f * float(wsum) / float(((2.0f * r + 1.0f) * (2.0f * r + 1.0f))));
            _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] =
                float4(
                        ExpAvg(centerAccum.rgb, accum.rgb, 0.75f),
                        ExpAvg(centerAccum.w, 0.0f, 0.75f)
                    );
        }
    }
    //else
    //{
    //    _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = 0.0f;
    //        //float4(ExpAvg(centerAccum.rgb, float3(0.0f, 0.0f, 0.0f), 0.95f), 1.0f);
    //}
#endif

    if (true || isNewHit)
    {
        //float weight = pdf;// *distCoef;
        //weight /= 4096.0f;
        //weight = min(weight, 4096.0f);
        //weight /= 4096.0f;
        //pdf /= 4096.0f;
        //if (pdf == 0.0f)
        //{
        //    weight = 1.0f;
        //}
        //pdf = min(pdf, 16.0f);
        //float wsum = centerAccum.w + weight;
        //if (wsum > 0.0f)
       // _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] =
       //     float4(centerAccum.rgb + (weight / wsum)*(center.rgb - centerAccum.rgb), wsum);
        _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(
            lerp(centerAccum.rgb, center.rgb, 0.00125f),
            /*lerp(centerAccum.w, pdf, 0.0125f)*/1.0f);
            //centerAccum * 0.75f + 0.25f * center;
            //lerp(centerAccum, center, 0.0175f);
            //lerp(centerAccum, center, 0.0125f);
            //ExpAvg(centerAccum, center, 1.0f - 0.0000125f);
            //float4(center.rgb, 1.0f);
            //float4(lerp(centerAccum.rgb, center.rgb, 0.0125f), 1.0f);
            //float4(
            //    ExpAvg(centerAccum.rgb, center.rgb, 0.000125f),
            //    ExpAvg(centerAccum.w, pdf, 0.000125f));
    }
    //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = 0.0f;
    /*else */if (false && centerAccum.w < 0.00125f)
    {
        const int r = 1;
        float4 accum = 0.0f;
        float wsum = 0.0f;
        for (int i = -r; i <= r; ++i)
        {
            for (int j = -r; j <= r; ++j)
            {
                float4 val0 = _SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS + int2(i, j))];
                float4 val1 = _SSRAccumTexture     [COORD_TEXTURE2D_X(positionSS + int2(i, j))];
                //float4 val  = val0 * 0.5f + 0.5f * val1;
                float4 val = val1;
                //if (i != 0 && j != 0 && dot(val.rgb, float3(1, 1, 1)) > 0.1f)
                if (i != 0 && j != 0)
                if (val.w > 0.0f)
                {
                    wsum += 1.0f;
                        //Luminance(val.rgb);
                        //val.w;
                    //accum += val.w*val;
                    accum += val;
                }
            }
        }
        if (wsum > 0.0f)
        {
            accum /= wsum;
            _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] =
                //float4(ExpAvg(centerAccum.rgb, accum.rgb, 0.125f), centerAccum.w);
                lerp(centerAccum, accum, 0.75f);
                //accum;
                //float4(accum.rgb, 1.0f);
        }
        //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(accum.rgb, 1.0f);
        //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = float4(ExpAvg(centerAccum.rgb, accum.rgb, 0.125f), 1.0f);
    }
    //else //if (false)
    //if (false)
    {
        //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = lerp(_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)], float4(0.0f, 0.0f, 0.0f, 0.0f), 0.05f);
        _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] =
            //lerp(_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)], float4(0.0f, 0.0f, 0.0f, 0.0f), saturate(10000000000000.0f*length(motionVectorNDC)));
            lerp(_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)], float4(0.0f, 0.0f, 0.0f, 0.0f), 0.1f);
      //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] =
      //    //float4(ExpAvg(centerAccum.rgb, float3(0.0f, 0.0f, 0.0f), 0.25f), 1.0f);
      //    ExpAvg(centerAccum, float4(0.0f, 0.0f, 0.0f, 0.0f), 0.125f);
    }
    //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = 0.0f;

    float3 output = 0.0f;
    int rad = 32;
    float tot = 0.0f;
    for (int x = -rad; x <= rad; ++x)
    {
        for (int y = -rad; y <= rad; ++y)
        {
            float4 data = _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS + int2(x, y))];
            //if (data.w > 0.0f)
            //if (x != 0 && y != 0)
            {
                //float sigma = lerp(0.125f, 16.0f, saturate(data.w/128.f));
                float sigma = lerp(0.125f, 128.0f, saturate(distCoef));
                float sigma2 = sigma * sigma;
                float coef = rcp(sigma2 * 2.0f * 3.1415926535897932354626f) * exp2(-(float(x * x + y * y) / (2.0f * sigma2)));
                tot += coef;
                output += coef * data;
            }
        }
    }
    output = output / tot;

    //_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)] = 0.0f;
    //_SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = float4(sqrt(_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)].x).xxx, 1.0f);
    //_SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = float4(_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)].www, 1.0f);
    //_SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = float4(distCoef.xxx, 1.0f);
    //_SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = float4(motionVectorNDC.rg, 0.0f, 1.0f);
    _SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = float4(output.xyz, 1.0f);
    //_SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = float4(_SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)].www, 1.0f);
    //_SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = _SSRAccumTexture[COORD_TEXTURE2D_X(positionSS)];

    //_SsrLightingTextureRW[COORD_TEXTURE2D_X(positionSS)] = 0*float4(1.0f, 1.0f, 1.0f, 1.0f);
}

#endif
